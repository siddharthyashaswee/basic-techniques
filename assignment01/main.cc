/*===========================================================================*/
/*                                                                           *
 * Copyright (c) 2020, Computer Graphics Group RWTH Aachen University        *
 *                            All rights reserved                            *
 *                                                                           *
 * Basic Techniques in Computer Graphics Exercise                            *
 *                            DO NOT EDIT THIS FILE!                         *
 *                                                                           */
/*===========================================================================*/

#include "assignment.hh"

#include <glm/ext.hpp>
#include <glm/glm.hpp>
#include <iostream>

/// decide whether to build solution or task. only works if you have the solution file :^)
#if VIEW_SOLUTIONS
using namespace solution;
#else
using namespace task;
#endif

/**
 * basic some definitions
 */
namespace
{
GLFWwindow* window;

auto windowWidth = 512u;
auto windowHeight = 512u;
}


int main(int /*argc*/, char* /*argv*/[])
{
    // Initialise GLFW
    if (!glfwInit())
    {
        std::cerr << "[Error] Init of GLFW failed. Terminating." << std::endl;
        glfwTerminate();
        return -1;
    }

    window = common::createWindow(windowWidth, windowHeight, "Basic Techniques in Computer Graphics - Assignment 1");

    if (!common::init(window))
    {
        glfwTerminate();
        return -1;
    }

    // Ensure we can capture the escape key being pressed below
    glfwSetInputMode(window, GLFW_STICKY_KEYS, 1);
    glfwSetWindowSizeCallback(window, common::resizeCallback);

    // Enable vertical sync (on cards that support it)
    glfwSwapInterval(1);

    bool exitProgram = false;
    bool holdDownAKey = false;
    bool holdDownBKey = false;
    bool holdDownCKey = false;
    bool holdDownDKey = false;
    int sceneToDraw = 1;

    glGetError(); // clear errors

    double startTimeInSeconds = glfwGetTime();
    do
    {
        glfwPollEvents();

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        double runTime = glfwGetTime() - startTimeInSeconds;
        drawScene(sceneToDraw, runTime);

        // Swap buffers
        glfwSwapBuffers(window);

        if (glGetError() != GL_NO_ERROR)
        {
            std::cerr << "some OpenGL errors during rendering" << std::endl;
        }

        if ((glfwGetKey(window, 'A') == GLFW_PRESS) && (!holdDownAKey))
        {
            holdDownAKey = true;
            sceneToDraw = 1;
        }
        if ((glfwGetKey(window, 'A') == GLFW_RELEASE) && (holdDownAKey))
            holdDownAKey = false;

        if ((glfwGetKey(window, 'B') == GLFW_PRESS) && (!holdDownBKey))
        {
            holdDownBKey = true;
            sceneToDraw = 2;
        }
        if ((glfwGetKey(window, 'B') == GLFW_RELEASE) && (holdDownBKey))
            holdDownBKey = false;

        if ((glfwGetKey(window, 'C') == GLFW_PRESS) && (!holdDownCKey))
        {
            holdDownCKey = true;
            sceneToDraw = 3;
        }
        if ((glfwGetKey(window, 'C') == GLFW_RELEASE) && (holdDownCKey))
            holdDownCKey = false;

        if ((glfwGetKey(window, 'D') == GLFW_PRESS) && (!holdDownDKey))
        {
            holdDownDKey = true;
            sceneToDraw = 4;
        }
        if ((glfwGetKey(window, 'D') == GLFW_RELEASE) && (holdDownDKey))
            holdDownDKey = false;


        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            exitProgram = true;

    } // Check if the window was closed
    while (!glfwWindowShouldClose(window) && !exitProgram);

    // clean up:
    deleteCustomResources();

    // Close OpenGL window and terminate GLFW
    glfwTerminate();

    exit(0);
}
