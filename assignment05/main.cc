/*===========================================================================*/
/*                                                                           *
 * Copyright (c) 2020, Computer Graphics Group RWTH Aachen University        *
 *                            All rights reserved                            *
 *                                                                           *
 * Basic Techniques in Computer Graphics Exercise                            *
 *                            DO NOT EDIT THIS FILE!                         *
 *                                                                           */
/*===========================================================================*/

#include "assignment.hh"

#include <glm/ext.hpp>
#include <glm/glm.hpp>
#include <iostream>

/// decide whether to build solution or task. only works if you have the solution file :^)
#if VIEW_SOLUTIONS
using namespace solution;
#else
using namespace task;
#endif


namespace
{
const auto windowWidth = 512u;
const auto windowHeight = 512u;
GLFWwindow* window;

GLuint vs, fs, prog;
const char* vsrc = "#version 150\n in vec4 aPosition; \n out vec2 texCoord; \n void main() { texCoord = aPosition.xy/2.0; texCoord += 0.5; "
                   "gl_Position = aPosition; }\n";
const char* fsrc
    = "#version 150\n out vec4 oColor; \n in vec2 texCoord; \n uniform sampler2D tex; \n void main() { oColor = texture(tex, texCoord); }\n";

GLuint arrayBuffer;
GLuint vao;
GLuint texture;

unsigned char textureData[windowWidth * windowHeight * 4];

}


/**********************************************************************************************************************
 * Returns true if a window with the desired context could get created.
 * Requested OpenGL version gets set by ACGL defines.
 */
bool createWindow(bool forceOpenGL32)
{
    /////////////////////////////////////////////////////////////////////////////////////
    // Configure OpenGL context
    //
    if (forceOpenGL32)
    {
        // request OpenGL 3.2, will return a 4.1 context on Mavericks as well
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    }

    // activate multisampling (second parameter is the number of samples):
    // glfwWindowHint( GLFW_SAMPLES, 8 );

    // request an OpenGL debug context:
    glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);

    // define whether the window can get resized:
    glfwWindowHint(GLFW_RESIZABLE, false);

    /////////////////////////////////////////////////////////////////////////////////////
    // try to create an OpenGL context in a window and check the supported OpenGL version:
    //                                                  R,G,B,A, Depth,Stencil
    window = glfwCreateWindow(windowWidth, windowHeight, "Basic Techniques in Computer Graphics", NULL, NULL);
    if (!window)
    {
        std::cerr << "Failed to open a GLFW window" << std::endl;
        return false;
    }
    glfwMakeContextCurrent(window);

    return true;
}

void initializeOpenGL()
{
    if (!gladLoadGL())
    {
        std::cerr << "[Error] Init of glad failed. Terminating." << std::endl;
        glfwTerminate();
        exit(-1);
    }
    glDebugMessageCallback(common::glDebugOutput, NULL);

    glClearColor(0.0, 0.0, 0.0, 1.0);
    glEnable(GL_DEPTH_TEST);
}


bool prepareExercise()
{
    // prepare the shaders:
    vs = glCreateShader(GL_VERTEX_SHADER);
    fs = glCreateShader(GL_FRAGMENT_SHADER);
    prog = glCreateProgram();

    // at least OpenGL 3.2
    glShaderSource(vs, 1, &vsrc, NULL);
    glShaderSource(fs, 1, &fsrc, NULL);

    glCompileShader(vs);
    common::checkCompileErrors(vs);
    glCompileShader(fs);
    common::checkCompileErrors(fs);

    glAttachShader(prog, vs);
    glAttachShader(prog, fs);

    glLinkProgram(prog);
    common::checkLinkErrors(prog);

    glUseProgram(prog);

    if (glGetError() != GL_NO_ERROR)
    {
        std::cerr << "could not prepare shaders" << std::endl;
        return false;
    }

    GLint attributeLocation;
    attributeLocation = glGetAttribLocation(prog, "aPosition");

    // prepare the geometry:
    const int componentsPerVertex = 4;
    float quad[componentsPerVertex * 4] = {-1.0, -1.0, -0.5, 1.0, -1.0, 1.0, -0.5, 1.0, 1.0, -1.0, -0.5, 1.0, 1.0, 1.0, -0.5, 1.0};

    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    glGenBuffers(1, &arrayBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, arrayBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(quad), quad, GL_STATIC_DRAW);

    glVertexAttribPointer(attributeLocation, componentsPerVertex, GL_FLOAT, GL_FALSE, componentsPerVertex * sizeof(float), 0);
    glEnableVertexAttribArray(attributeLocation);

    if (glGetError() != GL_NO_ERROR)
    {
        std::cerr << "could not prepare geometry" << std::endl;
        return false;
    }

    // prepare texture:
    glGenTextures(1, &texture);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, windowWidth, windowHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, textureData);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    if (glGetError() != GL_NO_ERROR)
    {
        std::cerr << "could not prepare texture" << std::endl;
        return false;
    }

    return true;
}

void cleanupExercise()
{
    glDeleteBuffers(1, &arrayBuffer);
    glDeleteVertexArrays(1, &vao);
    glDeleteProgram(prog);
    glDeleteShader(vs);
    glDeleteShader(fs);
    glDeleteTextures(1, &texture);
}

void drawQuad()
{
    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, windowWidth, windowHeight, GL_RGBA, GL_UNSIGNED_BYTE, textureData);

    GLint uniformLocation = glGetUniformLocation(prog, "tex");
    glUniform1i(uniformLocation, 0);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
}

/*
 * Use this function to update the texture:
 * x,y are pixel coordinates and should be in range of [0..windowWidth-1] [0..windowHeight-1]
 * color is a r,g,b color with each channel from [0..1]
 */
void setPixel(int x, int y, glm::vec3 color)
{
    color = glm::clamp(color, glm::vec3(0.0, 0.0, 0.0), glm::vec3(1.0, 1.0, 1.0));
    textureData[(y * windowWidth + x) * 4 + 0] = (unsigned char)(color.r * 255.0);
    textureData[(y * windowWidth + x) * 4 + 1] = (unsigned char)(color.g * 255.0);
    textureData[(y * windowWidth + x) * 4 + 2] = (unsigned char)(color.b * 255.0);
    textureData[(y * windowWidth + x) * 4 + 3] = 255;
}

void callStudentCode(int sceneToDraw, double runTime)
{
    drawScene(sceneToDraw, runTime);
    drawQuad();
}

void resizeCallback(GLFWwindow*, int newWidth, int newHeight)
{
    // define the part of the screen OpenGL should draw to (in pixels):
    glViewport(0, 0, newWidth, newHeight);
}


int main(int /*argc*/, char* /*argv*/[])
{
    // Initialise GLFW
    if (!glfwInit())
    {
        std::cerr << "[Error] Init of GLFW failed. Terminating." << std::endl;
        glfwTerminate();
        return -1;
    }

    window = common::createWindow(windowWidth, windowHeight, "Basic Techniques in Computer Graphics - Assignment 5");

    if (!window)
        std::cerr << "[Error] Window could not be created!" << std::endl;

    if (!common::init(window))
    {
        glfwTerminate();
        return -1;
    }

    // Ensure we can capture the escape key being pressed below
    glfwSetInputMode(window, GLFW_STICKY_KEYS, 1);
    glfwSetWindowSizeCallback(window, resizeCallback);

    // Enable vertical sync (on cards that support it)
    // vertical sync
    int vSync = 1;
    glfwSwapInterval(vSync);

    bool exitProgram = false;
    bool holdDownAKey = false;
    bool holdDownBKey = false;
    bool holdDownCKey = false;
    bool holdDownDKey = false;
    bool holdDownVKey = false;
    int sceneToDraw = 1;
    glGetError(); // clear errors

    if (!prepareExercise())
        exit(-1);

    initCustomResources();

    double startTimeInSeconds = glfwGetTime();
    do
    {
        glfwPollEvents();

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        double runTime = glfwGetTime() - startTimeInSeconds;

        callStudentCode(sceneToDraw, runTime);

        // Swap buffers
        glfwSwapBuffers(window);

        if ((glfwGetKey(window, 'A') == GLFW_PRESS) && (!holdDownAKey))
        {
            holdDownAKey = true;
            sceneToDraw = 1;
        }
        if ((glfwGetKey(window, 'A') == GLFW_RELEASE) && (holdDownAKey))
            holdDownAKey = false;

        if ((glfwGetKey(window, 'B') == GLFW_PRESS) && (!holdDownBKey))
        {
            holdDownBKey = true;
            sceneToDraw = 2;
        }
        if ((glfwGetKey(window, 'B') == GLFW_RELEASE) && (holdDownBKey))
            holdDownBKey = false;

        if ((glfwGetKey(window, 'C') == GLFW_PRESS) && (!holdDownCKey))
        {
            holdDownCKey = true;
            sceneToDraw = 3;
        }
        if ((glfwGetKey(window, 'C') == GLFW_RELEASE) && (holdDownCKey))
            holdDownCKey = false;

        if ((glfwGetKey(window, 'D') == GLFW_PRESS) && (!holdDownDKey))
        {
            holdDownDKey = true;
            sceneToDraw = 4;
        }
        if ((glfwGetKey(window, 'D') == GLFW_RELEASE) && (holdDownDKey))
            holdDownDKey = false;


        if ((glfwGetKey(window, 'V') == GLFW_PRESS) && (!holdDownVKey))
        {
            holdDownVKey = true;
            vSync = (vSync + 1) % 2;
            std::cout << "vsync is ";
            if (vSync)
                std::cout << "on";
            else
                std::cout << "off";
            std::cout << std::endl;
            glfwSwapInterval(vSync);
        }
        if ((glfwGetKey(window, 'V') == GLFW_RELEASE) && (holdDownVKey))
            holdDownVKey = false;


        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            exitProgram = true;

    } // Check if the window was closed
    while (!glfwWindowShouldClose(window) && !exitProgram);

    // clean up:
    deleteCustomResources();
    cleanupExercise();

    // Close OpenGL window and terminate GLFW
    glfwTerminate();

    exit(0);
}
