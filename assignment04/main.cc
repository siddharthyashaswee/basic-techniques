/*===========================================================================*/
/*                                                                           *
 * Copyright (c) 2020, Computer Graphics Group RWTH Aachen University        *
 *                            All rights reserved                            *
 *                                                                           *
 * Basic Techniques in Computer Graphics Exercise                            *
 *                            DO NOT EDIT THIS FILE!                         *
 *                                                                           */
/*===========================================================================*/

#include "assignment.hh"

#include <glm/ext.hpp>
#include <glm/glm.hpp>
#include <iostream>

// assignment specific includes:
#include "sphere.hh"

/// decide whether to build solution or task. only works if you have the solution file :^)
#if VIEW_SOLUTIONS
using namespace solution;
#else
using namespace task;
#endif


namespace
{
// assignment specific variables:
GLuint vs, fs, prog;
const char* vsrc = "#version 150\n in vec4 aPosition; \n out vec3 n; \n uniform mat4 modelView; \n uniform mat4 projection; \n void main() { "
                   "gl_Position = projection*modelView*aPosition; n = (transpose(inverse(mat3(modelView)))*aPosition.xyz); }\n";
const char* fsrc = "#version 150\n out vec4 oColor; \n in vec3 n; \n uniform vec3 color; void main() { oColor = vec4( dot( vec3(0,0,1),normalize(n)) "
                   "* color, 1.0 ); }\n";
GLuint arrayBuffer;
GLuint vao;
Sphere sphere(10);
const int outerPoints = 48;

auto windowWidth = 1024u;
auto windowHeight = 1024u;

GLFWwindow* window;
}

/// extern defined in main.h (for some reason)
bool arrowKeyUpPressed = false;
bool arrowKeyLeftPressed = false;
bool arrowKeyRightPressed = false;
bool arrowKeyDownPressed = false;


/**
 * This function will draw a rough approximation of a circle in a given color and a given transformation.
 * The coordinate system has its center in the center of the application window.
 * The window spans the range from -1 to 1 on the X and Y axis.
 */
void drawCircle(const glm::vec3& color, const glm::mat4& model, const glm::mat4& view, const glm::mat4& projection)
{
    // set the color:
    GLint uniformLocation = glGetUniformLocation(prog, "color");
    glUniform3f(uniformLocation, color.r, color.g, color.b);

    // set the transformation:
    uniformLocation = glGetUniformLocation(prog, "modelView");
    glm::mat4 modelView = view * model;


    glUniformMatrix4fv(uniformLocation, 1, GL_FALSE, glm::value_ptr(modelView));
    uniformLocation = glGetUniformLocation(prog, "projection");
    glUniformMatrix4fv(uniformLocation, 1, GL_FALSE, glm::value_ptr(projection));

    sphere.draw();
}

bool prepareExercise()
{
    // prepare the shaders:
    vs = glCreateShader(GL_VERTEX_SHADER);
    fs = glCreateShader(GL_FRAGMENT_SHADER);
    prog = glCreateProgram();

    // at least OpenGL 3.2
    glShaderSource(vs, 1, &vsrc, NULL);
    glShaderSource(fs, 1, &fsrc, NULL);

    glCompileShader(vs);
    common::checkCompileErrors(vs);
    glCompileShader(fs);
    common::checkCompileErrors(fs);

    glAttachShader(prog, vs);
    glAttachShader(prog, fs);

    glLinkProgram(prog);
    common::checkLinkErrors(prog);

    glUseProgram(prog);

    if (glGetError() != GL_NO_ERROR)
    {
        std::cerr << "could not prepare shaders" << std::endl;
        return false;
    }

    GLint attributeLocation;
    attributeLocation = glGetAttribLocation(prog, "aPosition");

    // prepare the geometry:
    const int componentsPerVertex = 4;
    float circle[componentsPerVertex * (1 + outerPoints + 1)];

    circle[0] = circle[1] = 0.0;
    circle[2] = -0.5;
    circle[3] = 1.0;
    for (int i = 0; i <= outerPoints; ++i)
    {
        circle[componentsPerVertex + (i * componentsPerVertex) + 0] = cos(2.0 * M_PI * i / outerPoints); // x
        circle[componentsPerVertex + (i * componentsPerVertex) + 1] = sin(2.0 * M_PI * i / outerPoints); // y
        circle[componentsPerVertex + (i * componentsPerVertex) + 2] = -0.5;                              // z
        circle[componentsPerVertex + (i * componentsPerVertex) + 3] = 1.0;                               // w
    }

    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    glGenBuffers(1, &arrayBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, arrayBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(circle), circle, GL_STATIC_DRAW);

    glVertexAttribPointer(attributeLocation, componentsPerVertex, GL_FLOAT, GL_FALSE, componentsPerVertex * sizeof(float), 0);
    glEnableVertexAttribArray(attributeLocation);

    if (glGetError() != GL_NO_ERROR)
    {
        std::cerr << "could not prepare geometry" << std::endl;
        return false;
    }

    return true;
}

void cleanupExercise()
{
    glDeleteBuffers(1, &arrayBuffer);
    glDeleteVertexArrays(1, &vao);
    glDeleteProgram(prog);
    glDeleteShader(vs);
    glDeleteShader(fs);
}

void callStudentCode(int sceneToDraw, double runTime)
{
    double time = runTime;
    if (sceneToDraw == 2)
        time *= 10;
    if (sceneToDraw == 5)
        time *= 5;
    drawScene(sceneToDraw, time);
}

int main(int /*argc*/, char* /*argv*/[])
{
    // Initialise GLFW
    if (!glfwInit())
    {
        std::cerr << "[Error] Init of GLFW failed. Terminating." << std::endl;
        glfwTerminate();
        return -1;
    }

    window = common::createWindow(windowWidth, windowHeight, "Basic Techniques in Computer Graphics - Assignment 4");

    if (!window)
        std::cerr << "[Error] Window could not be created!" << std::endl;

    if (!common::init(window))
    {
        glfwTerminate();
        return -1;
    }

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);


    // Ensure we can capture the escape key being pressed below
    glfwSetInputMode(window, GLFW_STICKY_KEYS, 1);
    glfwSetWindowSizeCallback(window, common::resizeCallback);
    resizeCallback(windowWidth, windowHeight);

    // Enable vertical sync (on cards that support it)
    // vertical sync
    int vSync = 1;
    glfwSwapInterval(vSync);

    bool exitProgram = false;
    bool holdDownAKey = false;
    bool holdDownBKey = false;
    bool holdDownCKey = false;
    bool holdDownDKey = false;
    int sceneToDraw = 1;
    glGetError(); // clear errors

    if (!prepareExercise())
        exit(-1);

    initCustomResources();

    double startTimeInSeconds = glfwGetTime();
    do
    {
        glfwPollEvents();

        if ((glfwGetKey(window, 'A') == GLFW_PRESS) && (!holdDownAKey))
        {
            holdDownAKey = true;
            sceneToDraw = 1;
        }
        if ((glfwGetKey(window, 'A') == GLFW_RELEASE) && (holdDownAKey))
            holdDownAKey = false;

        if ((glfwGetKey(window, 'B') == GLFW_PRESS) && (!holdDownBKey))
        {
            holdDownBKey = true;
            sceneToDraw = 2;
        }
        if ((glfwGetKey(window, 'B') == GLFW_RELEASE) && (holdDownBKey))
            holdDownBKey = false;

        if ((glfwGetKey(window, 'C') == GLFW_PRESS) && (!holdDownCKey))
        {
            holdDownCKey = true;
            sceneToDraw = 3;
        }
        if ((glfwGetKey(window, 'C') == GLFW_RELEASE) && (holdDownCKey))
            holdDownCKey = false;

        if ((glfwGetKey(window, 'D') == GLFW_PRESS) && (!holdDownDKey))
        {
            holdDownDKey = true;
            sceneToDraw = 4;
        }
        if ((glfwGetKey(window, 'D') == GLFW_RELEASE) && (holdDownDKey))
            holdDownDKey = false;

        if ((glfwGetKey(window, 'E') == GLFW_PRESS) && (!holdDownCKey))
        {
            holdDownCKey = true;
            sceneToDraw = 5;
        }
        if ((glfwGetKey(window, 'E') == GLFW_RELEASE) && (holdDownCKey))
            holdDownCKey = false;

        arrowKeyRightPressed = (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS);
        arrowKeyLeftPressed = (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS);
        arrowKeyUpPressed = (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS);
        arrowKeyDownPressed = (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS);

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        double runTime = glfwGetTime() - startTimeInSeconds;
        callStudentCode(sceneToDraw, runTime);

        // Swap buffers
        glfwSwapBuffers(window);

        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            exitProgram = true;

    } // Check if the window was closed
    while (!glfwWindowShouldClose(window) && !exitProgram);

    // clean up:
    deleteCustomResources();

    cleanupExercise();

    // Close OpenGL window and terminate GLFW
    glfwTerminate();

    exit(0);
}
